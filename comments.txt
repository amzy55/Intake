
//float Entity::DistancePlayerEnemy(Entity* enemy, Tmpl8::vec2 TileMapOffset)
//{
//	//float distancePlayerEnemy = sqrtf(powf(player->GetPosition().x - (enemy->GetPosition().x - TileMapOffset.x), 2) + powf(player->GetPosition().y - (enemy->GetPosition().y - TileMapOffset.y), 2));
//
//	Tmpl8::vec2 playerPos = m_position;
//	Tmpl8::vec2 enemyPos = enemy->GetPosition(TileMapOffset);
//	float distancePlayerEnemy = (playerPos - enemyPos).length();
//
//	return distancePlayerEnemy;
//}
		
/*if (distancePlayerEnemy < SNOW_TILE.width * 3)
{
	if (distancePlayerEnemy < SNOW_TILE.width)
	{
		vec2 enemyNewPos = { static_cast<float>(IRand(800)), static_cast<float>(IRand(512)) };
		enemy->SetPosition(enemyNewPos);
	}

	if (EnemyPos.x < PlayerPos.x)
		enemyMoveBy.x += enemySpeed * deltaTime;

	if (EnemyPos.x > PlayerPos.x)
		enemyMoveBy.x -= enemySpeed * deltaTime;

	if (EnemyPos.y < PlayerPos.y)
		enemyMoveBy.y += enemySpeed * deltaTime;

	if (EnemyPos.y > PlayerPos.y)
		enemyMoveBy.y -= enemySpeed * deltaTime;

	enemy->Move(enemyMoveBy);
}*/

//vec2 playerUpperLeft = playerPos - (TILE_SIZE * player->GetAnchor());
//vec2 playerBottomRight = playerPos + (TILE_SIZE * player->GetAnchor());
//Bounds playerBounds(playerUpperLeft, playerBottomRight);
//Pixel BarColorChosen = BarColor[1];
//if (tileMap->Collides(playerBounds))
//	BarColorChosen = BarColor[0];
//	//player->SetPosition({ Rand(screen->GetWidth()), Rand(screen->GetHeight()) });


